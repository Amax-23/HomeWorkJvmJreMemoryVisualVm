## Домашнее задание по теме «JVM. Организация памяти, сборщики мусора, VisualVM»

### Задача 1 (обязательная)
Просмотрите код и опишите (текстово или с картинками) в README каждую строку с точки зрения происходящего в JVM.

Не забудьте упомянуть про:

- ClassLoader’ы,
- области памяти (стэк (и его фреймы), heap)
- сборщик мусора

## Решение задачи (описание пронумеровано, согласно номеров строк в коде):
- Как только мы запустим программу, загружаются все классы среды выполнения в область памяти Metaspace, предварительно происходит процесс инициализации классов,  в котором используется подсистема ClassLoader - загрузчики классов, состоящая из Bootstrap ClassLoader(младший), Platform Class Loader(средний), Application ClassLoader(старший), использующие делегирование загрузки классов разных уровней(т.н. "ленивая" подгрузка). Данная подсистема подготавливает классы к выполнению и проверяет, что код валиден, подготавливает примитивы в статистических полях, связывает ссылки на другие классы  (процесс называется Linking). Выделяется память, для хранения всех данных о классе и после чего, данные преобразованные в байткод, передаются на исполнение в JVM.

    Когда происходит вызов метода main, Java Runtime создает фрейм(кадр) main  в области памяти Stack Memory для использования этим методом.
1.	Берется число 1, ложиться фрейм main в области памяти Stack Memory и сохраняется в переменную «i».
2.	В heap(куче) создается объект класса Objekt, а фрейм main в области памяти Stack Memory создается ссылка на этот объект, которая присваивается переменной «о».
3.	В heap(куче) создается объект класса Integer со значением 2, а фрейм main в области памяти Stack Memory создается ссылка на этот объект - «ii».
4.	В момент вызова статичного метода printAll() в области памяти Stack Memory на верху создается фрейм printAll, в котором записывается ссылка на объект «о», переменную «i» и ссылку «ii», которые передаются в качестве параметров в метод private static void printAll(Object o, int i, Integer ii).
5.	Берется число 700, и в области памяти Stack Memory в фрейме printAll сохраняется в переменную «uselessVar».
6.	Происходит обращение в стек с getstatic к статическому полю out класса System, у которого вызываем метод println(), при этом, в качестве аргументов используются ссылка на объект «о», преобразованного методом toString() в строковое состояние, также передаются значения суммы переменных типа Integer «i» и «ii». Созданная строка, передается в Пул строк (String Pool), который находится в heap(куча). На эту строку создается ссылка в области памяти Stack Memory метода printAll().

Метод printAll() завершает работу, срабатывает сборщик мусора Garbage Collector, поэтому блок в области памяти Stack Memory в фрейме printAll для этого метода становится свободным.

7.	Происходит обращение в стек с getstatic к статическому полю out класса System, у которого вызываем метод println(), при этом, в качестве аргументов используются ссылка на вновь созданный  объект в куче типа String “finished ”. Созданная строка, передается в Пул строк (String Pool), который находится в heap(куча). На эту строку создается ссылка в области памяти Stack Memory метода main().

Метод main() завершается, также программа заканчивается в этой строке, следовательно, Java Runtime освобождает всю память и завершает программу.

